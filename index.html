<html class="staticrypt-html"><head>
        <meta charset="utf-8">
       <head>
    <meta charset="utf-8">
    
    <title>Acc√®s R√©visions</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üå©Ô∏è</text></svg>">

    <meta http-equiv="cache-control" content="max-age=0">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="expires" content="0">
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT">
        <meta http-equiv="pragma" content="no-cache">

        <style>
    /* --- THEME SOBER TECH (PRO) --- */
    :root {
        --bg-color: #0f1115;       /* Noir profond */
        --card-bg: #161b22;        /* Gris fonc√© mat */
        --border-color: #30363d;   /* Bordures subtiles */
        --accent-color: #2f81f7;   /* Bleu professionnel */
        --text-primary: #f0f6fc;   /* Blanc cass√© */
        --text-secondary: #8b949e; /* Gris d√©tails */
        --font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    body {
        margin: 0; padding: 0;
        background-color: var(--bg-color);
        font-family: var(--font-stack);
        color: var(--text-primary);
        height: 100vh;
        display: flex; align-items: center; justify-content: center;
        background-image: radial-gradient(circle at 50% 0%, #1c2128 0%, var(--bg-color) 70%);
    }

    .staticrypt-page {
        width: 100%;
        max-width: 420px;
        padding: 20px;
        box-sizing: border-box;
    }

    .staticrypt-form {
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 40px;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
        text-align: center;
        position: relative;
    }

    .staticrypt-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--text-primary);
        letter-spacing: -0.5px;
    }
    
    .staticrypt-instructions p {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-top: 0;
    }

    .staticrypt-hr {
        border: 0;
        border-top: 1px solid var(--border-color);
        margin: 25px 0;
    }

    .staticrypt-password-container {
        position: relative;
        margin-bottom: 20px;
    }

    .staticrypt-form input[type="password"], 
    .staticrypt-form input[type="text"] {
        width: 100%;
        padding: 12px 16px;
        background: #0d1117;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        color: var(--text-primary);
        font-family: inherit;
        font-size: 1rem;
        outline: none;
        transition: all 0.2s ease;
        box-sizing: border-box;
    }

    .staticrypt-form input:focus {
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px rgba(47, 129, 247, 0.15);
    }

    .staticrypt-form .staticrypt-decrypt-button {
        width: 100%;
        padding: 12px;
        background: var(--accent-color);
        border: none;
        border-radius: 6px;
        color: #ffffff;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
        margin-top: 10px;
    }

    .staticrypt-form .staticrypt-decrypt-button:hover {
        background: #58a6ff;
    }

    label.staticrypt-remember {
        display: flex; align-items: center; justify-content: center;
        font-size: 0.85rem; color: var(--text-secondary);
        margin-bottom: 20px; cursor: pointer;
    }

    .staticrypt-remember input[type="checkbox"] {
        margin-right: 8px; accent-color: var(--accent-color); transform: scale(1.1);
    }

    .staticrypt-toggle-password-visibility {
        position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
        cursor: pointer; opacity: 0.5; width: 18px; filter: invert(1);
    }
    .staticrypt-toggle-password-visibility:hover { opacity: 0.8; }

    .hidden { display: none !important; }

    .staticrypt-spinner-container {
        height: 100vh; display: flex; justify-content: center; align-items: center;
    }
    .staticrypt-spinner {
        width: 40px; height: 40px;
        border: 3px solid var(--border-color);
        border-top-color: var(--accent-color);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* Responsive Mobile */
    @media (max-width: 480px) {
        .staticrypt-form { padding: 25px; }
    }
/* --- STYLE DU LOGO FLOTTANT --- */
    .staticrypt-logo {
        font-size: 4rem;  /* Taille du logo */
        margin-bottom: 10px;
        cursor: default;
        /* Ombre port√©e pour effet de profondeur */
        filter: drop-shadow(0 10px 10px rgba(0,0,0,0.5));
        /* L'animation qui le fait bouger */
        animation: float 3s ease-in-out infinite;
    }

    /* D√©finition du mouvement de flottaison */
    @keyframes float {
        0% {
            transform: translateY(0px);
        }
        50% {
            transform: translateY(-15px); /* Il monte de 15 pixels */
        }
        100% {
            transform: translateY(0px);
        }
    }
</style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container hidden">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
		<div class="staticrypt-logo">üå©Ô∏è</div>
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Acc√®s r√©vision BTS-CIEL</p>
                        <p class="staticrypt-title"> Par Piton Tristan</p>
                    </div>

                    <hr class="staticrypt-hr">

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
			<div class="staticrypt-password-container">
    <input id="staticrypt-username" type="text" placeholder="Votre Nom / Pseudo" style="margin-bottom: 15px;">
</div>
                            <input id="staticrypt-password" type="password" name="password" placeholder="Mot de passe" autofocus="">

                            <img class="staticrypt-toggle-password-visibility" alt="template_toggle_show" title="template_toggle_show" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==">
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember">Se souvenir de moi</label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Acc√®s">
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6084909d6793f2d93f18c9d8d226afaea81a88f49d21f46a7b4320312defbb36e3e5507ca29600547029e7b232b1062f192f361c371ebda47f6cc52ecdc344277acdd5e679fe2a08bc4ca7138c56558ebd1c8dda1dfdd73709f3138c212953471e59c5b556e15bb2ed058ddf350cf4116ac314f0f29faba49de445f4aacc7c5c5eca813fe51fc1aeec8dc0913f74aa13c6c81c1d9e74ae8323e9b0b5bfa9f6757e5fd3aaeb4f3f80caa1cd427f5d0217f892e7305c453707188caebce71cceeb55f500df0632e3d11329aa7b68235fa7a0cca8b8083ab232e6f4a50877b7b47eefdebe81a9d873aae133599bd9b3fba946cdf07863c023684f8891f1e1827d61b28fa6a567f8bad29ea0a6527dcd58191ecc3add60b7ac9040583180787607bcc301707aa68217edc39b06c4dc144582b4d96d32813d677da88c2be0902903b05cbcb921839bd5e05fbe51706d37af4923bb26e5df1d26056a84c76fb1fcd6301992593da6646246a8cd2acf5b566197c2d41c0f6667ac21f3c317cf5a5e9732094af1bf9c0ac47ad253380938ce1227c6726d95e532ed7dfd69ab3864ac7b796313ed83fecf41381ce0925aa968425d08f2a9f7733a739030049dc96ca842dfd9ba69583e606088c5d0a5eb5f11efc381e5d08704b4468d3a715615cc35fb87fd34e5dffd4c9991ba9c642c73da46429c77b20fdde72e125e481fe875e5a63c6a978311bd520cb90df41224bfeee0e9e17a854fae9466cda775c7c9faf518fd7affd08b3e487513904fc84d540797e04dc6015506b913f2ddd243ba8074c15da9c35d02c98d466da9173d216817d3dc7e5570edfb191875826d47efefc06af6ae46f8bff1b2d95a0ca6fe64dfa2369ef692b59185ef20f64d94bcd139382dcc247ccda270a29e2b375ba5602db5163e1c39f250beaea39f5ba15d85d8ac892a906ffcd0d1a7b0dce15f2572cdb4c0ed7464f52a489a9bef83e94c63516132ca9b62b6353f6093febf888646dfc5dbd5e8511417cf7069d664abc4b6f72312ff6c4bab03f6282a65e9233a5b875ce232bae03320e6171b2b28133cb1bc94fa84529a71827a1e0910f8db1606a3a4076c92965e5df9d99d965cebc26afd115e51a855449c04798a637975b3bbbacc68265ec71e3d2bdb57029f8ab101e6ce8f876ad13b6f530b4d3c2a0790970aeded2917b6ad89393ae4c03757f5ae94c18dc16d88ec0e84913a00a16f3f3c7adcb6d5163f6836e67e97c80aeac76062c1d67b37c3360392d3303523a2dc405110da3cda7c33b9b8ddd9866007115e5fe373529f81287fc0eb692f28e242ad2554c797eefff948da847cb0e1f7ab508332342a7a8a92651b04b81d4bbcedd6bc107d07426f464250bb6f5bff6a6b72be86db80c1bc32d78001f38f3a388f52d7bbbb1c94eed16dc47131ec67a366fda69a50e4c7301af3577e7b719c1a332e30ed1416110edba49f3060bc9388aeedc0bb452059ec13e6c20f3aa69694e314138c2eec882a7833562e810da4dde5f4d62c5d6d782afe0da2a761076b792ac0b8d40ac8dc68e1afe01a46382f922d9f96165b8f830f2132a4d082979373ed937367721052fb1f4d648b29400037c87320b6e6a66681512985361f7148ee8b6eb2d3e115bb269578a816115674c08299607137a242f81b480e9e6086b235c84eb5651c4633824557d3c19f3eae620bb7a620a2d8b0f6f398edca71f247e4a010b7d8e0e5003f2672b5dc73473947a5a14784d95f1948889cdb58325839601a6ee2da960f661f9ea024dc3a3b0aef80d0ac6284e12bab3b6e40fd3aa0fd820dbcb20fe85ec8bd7662795c2c3a1ef368d6dca19762b48e869f2e2def284c2227c371701ecbcdc319e3b0995ea3588670befaebc7f72d4033ee3d7df43a0d7443f6903859760ea7f5a3a425fdc61e07552d4a50309318939a0dc04d843761224f4f98176cebe13c9bc2cf0d82e58da5c52ded2a96797e973975641c9bd621973483af98dd58d6801f5f2bc373ddfbeaff9b5fab858bedaaf350380815c01823d448298263e1284a2c5b15b349bf68d3b599f67672e3f196a24538431d436e6e4a124498e5d7344e52a7d3a258d1d56c9bfe393f8c298275dc4345a4c963509c1d01cfd248dee573d98d8d42bdbcd1b2ce722a3d408345d50837f56d2e7558e23ccd9801a98e889749460227e30eaa00851ea23137a33a5e87f6f95843dfc7df8eacb33e9100d8f4fe9767917afa1e96bfb0ac60419d961b304e6a66dce8a9847ff271683d289a05d9cfe1736eceab78ed8ac404a24d95d7c05737f97503d6da560f0ac09c4d6302d7e4d10bb79fb3ea5a1edea0184bae11f1143cfa94cea4873d0ece48b2a641f40f248cfa1990bd52e126039652b0feb9b2dd8da66414c44c7e4ea565f47c695fa18b7d42569c84f7441612342bce64590262309e6d59c0d3057661401bc8517529a67ed0185c5196ec1a4c7125371b7dffe64565aad2683b8a571cb3ddd07f1a8ee37d926ce6319f1f1de36794b6f81146524c30c99c9e4d14103e7a2e902b84314f5face9bd71f804b59918d64a3f1229ab4ff473320c6dfa1532572ecb5738db4c3307df784f0eb909acc29eb3cd5ebe29257a9202872f63b0882d148214f411911609353dc01c753f22ea0fd0ed57a971f33796d5fc622d7287e49bbcb7dcc1ac548b7830e01fa15defb59a5a554e485b99db2460260fc5eb35e435cab88cfa67ae1cde87032923dc165b32d6abbef84d30d84c2caaf6d14e4d1733c823a317844cc603962355638c8887a0e9775fbd087df1b7b1ba820f041f0a9f0e9989453c6a229f8f7ca6dba17da333c08176cd0e6ea6aa7710ecb764e1297c38177542d1bf4d932365acae5f4e80e0d87b4426bce7d9deabcc0ea853c123a420ab82eddb2bf6fb212c1370191e83ee9073d39a670cd5be4cda66eea682b9ecf50f5ad19a241327d194507bb6fa7fc7ade24d949a7ba16e1eb9f21a8d6281dfdb057df7fbe7c8d2d4ded6562c8e9b6bfe985f506573412c6e3db9272a41485b9a64746438c44bb49d661294516286261bf1b0172358b7c712fef3c229f7875b1f86fc5f77e5e609e1347a3b37489332538df287d24b558237e401334ad374788e287cb966a7256033622d930056d8854880a1e97dfa90c1efd4b57033edc68dcd09c104c93fd829fa50590454ec73d698a62a866a02eee715815b17e4af90623247213cc8f4be5befd8abe2d0bc075960ebc2ceeb5d1a06977df060c0e3f9a5e29fa9a4657bfa886c03aae43a96a857a4a56e647c9ddba2862842e2eee3a85db0a72275c5118f372c65a98277e5956ee7f3a0f3505db86b8986fc1c44faa5ba1dae4c73ef8382339dec6bc298889feecd83d12cbc5a81c65cde24d73249e57c13dd38f8780d86edf703d5cfb4ce802bba98e581c76ea006deca7403e973919377f2d1d76605000d93f5225b1eeaa8072fc3e5829518b2e0cef7c9f91e4707be3aab27e62a79577e07522820bb4093fc213562b6fb7c9208af95e32cc64fb23a7e25865f9e1c116a994daa5e4abb679efab2b942422b9b2a63cea286ba53b3eccc18d58e29a9fa45ce73ef59ed49a898d8a9db00952fecc377a98149a5b46df6e114e90b2b33ebf896f09fa6944c8ed84716b3f9c5b4988e9794243a7be0dc2e1cd0d7139afd04a065e45b93d7da4f3f1a1f311d529ec0ea00db12585c34bf81adac6e92fb51a5872e8d4f8264e520499c8351936248c0f746f30d4c07877ee4f84af86e27b1982b5fb247353557c5a669995b6fa37470c1a4121943c8e4c179f6c2178439b4350a6a3464ad0a32dd7ffecce806c25fa3f875602ee8e635b9a02e6ba42c5cb1a7521c00698e2873caec012fe1dfd5650f162170056c3ba69806ac32f24a265a643410aa0fe6a95dcd992f8ff100247e80b17d620c6c56b0997279fbde62edf3babd004c7b81fd3087e53490beab2c76880aa5178d8cba83b37c3b7eb0b4ae1ecf0b346260f41ac90e6e8316d36fc026b9a29039ae2b7d314607a4023bf1ba9406726032ee789a2bd127206d4eb6484f61e7c72698121b0880442de3a30d1cfbb75bad31dfe26366d5ad17d9d79b3c6a8827003e5e692c9fef9e6a61ac28ce7c1af1ef7546cb29349645d945ee70d4b481e9bbb51b2d843830ffbd0d4f36652b93886f16d96b8b2e5a805b9c4ae07fd0295f4e94d9de3faa58966a20ad566322f9980eef7057265a4c5afed94e8fe70126b237016d78971efc01cb07a61e430337c5156117121778acd6b13266cf6db661662d5fe251806b764c4e1ecc68bc1e9c676f324a898f103ea0e08864bf97229702a3f2ad5a25b7739ff1ff599964879f2cac14708a3ef9c3951f2660a21b3cfeff64016c1a4781b2f5b09ce8d29030a22a1cebef27b933b59a46e051d463992cf08e0d4296514f62f187972ccd3f8c291a064bf43014fea906bdf9356b54d049fc23be2dd2349dea2e5590824d567318829bc3961169dce65e79916f972160ead5a828a9a67a8fabbc7ca166f6c9b2536ec782eb0a3ebc7fe9e0ad7ccf58d51b7906005d0aa134a3168c89f93fade154a087475838926e90654222fb8aba86634233d08f559e35b81a6179956605c57a42ecd0ef4e300fe41660478964636b3021ccb7bee347850e2f12660572c2a3b5ec9f25ec32de54f15a5d0e0eed1fe80a770c899f02f3f03274e0c2965a204fd09edc37c5b1efcfb3cffebfb8b5cc5cd53f83715f1b66528212bb8a5256a0066326e6067f6b51d7967d7972a1fe09b520ae38d606d44498e10d5395434af2efd05c30880a5081ac657c0304a7cbd9d0737ebf2a270f986f9f271fa1fc17306149921bfcdbda8084f97a9e56e3e9791a8be580475b06c3b7a47af8888217bd3ea67ad66503f5b08d4971948a9e4d693dbec86366b467a741dc7a344053b712ba615acbc9294c0ffe2f7dc92938eac88112bb0e6ef490897e6338c54a36d567dc55392b74db3a9fa764dc3eaecbb5ae1acfd8251962d93e04e32e94f58c1a095ac37c09ba64e0666258c0f4e10cd13b436422cff48ec952ef2cbebfcb199ce65333ffc2b2df1a1637a42c380aaab06f6b6501244e93c860584b6014bb65727d8d2a14acf02f86b270d81f823e986e25b6437142cf58d48511a32673590e526c02f91e4e029b5d3876cdde680cca28b9c0c3a42b027420c59589a374e29d53962abaccf96cfa26ee2146d00721a07a146ccb2029293cfa206ef021929137464a3446fb6de9c061e00ac61383ae9618692f0b27d0d55abd6dc034faaab160fe5f1dcad342605eb4e9d36f0864f5022f2b11d220063ccc7dcbcdd73a3189b4d9774ca5c15cd4380d34aff94c7cfce4d28a8d68a25236e322d8612033009e8243b8f1974d298090d08dce6cbc5038854321de807a423ef24a81d7b91a6a369ab2457563fc70bc11a38269e5c254c2e208488fe03cba849243d5e1d63a53825883f2a4bf70b707e434ba94cfffdfa5802d82ed260aa4f2110378be61ff839f1f1b7984733572f1a4f07f75c9c3dfca19570984dc716b932ef4c2b6ab14eba30348f34db2fe018c36423178a1be1fa656041a72f101656b70129eb4c116c1d63ecf5a90d59be73f0a004c92644f6af28bcdc1784dd4e2106bc3881fc8fcfe7aa3c76050fa72a3e2601d714d1180341c93698d105a55873933651be0a8d527a377c45ba36def8d910e5ed89ff4fcc6c216c075153a533b00f38c4a1afba6479619b6617fe53f82f6a3f5763cf836e16154de527c605ea26c1978b82628d7dc18f1045bc46cf684f190e9c0cdce430d64d04ee18aedcf6001fc353425ec082e820310d090c6f84e44737596bbdf58f240da84538739e2227bd949df9173c90d8c35a4ecf4378298c47788964656a1c103c70fc570a59c9df921a432bd8b07d9e2859e7a781e4ef6743b15f8203703fabcc7833134be8d00d6e3697a4c9651ec01cec2f9d948c7b13d711d846115f823079d6626a9e94a85251866f7e1432f49778bd3162f2f539683b53fc7c3d64c0fad02e2d7933faa30e5f715b634043286299a0d626439587f5782c3b8e8a63df5af2c349e351063fc36c843b0e119be349f9cee790ea83746e953445ed685a146d481fd2a7b4cc1d8f3b8e794119d305ccc40d8c26181c6707dea0444fd8a2522c0e2a5ca5cd750d075eb7dc126b338dbd2d07552729b50179143e9b2bd19e8e1490b40583dd1b6d4a52a418c6d199cb628d3b9bcb70ee7467fcd0ef094d771f9c08b26897759c7944b91cd23bfcddad1504ead97dafd75deaaed5eaa9f5e7ce841c941ffec4875c24e38fbd4e1b704e0942fa5f48880512c39a317e29118ad70e1d8bcdcbca97bad68604b119e668c1cd84a0a540158f51e8a5689a5312767dc2a43c96f5fa6313de2dc16e3c1af029ae6762aedc3e831eab0f9ea80925a2f18414d9bc5f201913ff2defbc7f933dfcd44d982f3ee205e1bd12b2f35ced7bf83e4a6cfd9979a7de898a5185ac28fd92a0e8c2b69796741ca688311afd74083d8c2c31aeff4f4f7733fc3088a93d483cc90c2c838c5e316a346874c5244278716789bc02651a123ecb0575b2101bf7245d82ba1147d7451ae4fdc152e1a346ed62912453c80e627c125da2c8ec2d70a356cfeec88d332dab46ce58c65aef6a4dd005fbc2f882cfd3a5348766e5422f6dfe39303b6bffa2293da4403eba7b53d2bbb2d7c23cf02203aaee45416a3392ee27d7ad77b51b969c27b2227222d496e7f94efcee37d242a7c97f16daff2c18eb859f9f14869596cb327e3ca92b83bf3321c722fdbb9f3d279fb5a8442ad81d2c5c6d0af16d7c8366634ebd2de1088decc5b52806fca19e250faa1a0627ff84a219497a2f0646a3f5817f4cd038f5e414026224ee60adc3b5feb58e2d06ca16a7ab144840f089b36c1611f69e348f85458b64d5b57f2f2f0fbb953109d919cb87a58a83eada509c2dff426cfd5a72fe9ee2845a8534220525840b61786617a2307e613df1f9a0f81e659274f09b3738d3617a556fabd0e96ea8c74b5e80bce6d02d57e3e922b09f546a3a0f799a8746b0d417ca081c7803efec717d026d9d1d9f2c0f562b06937a56050d12fe9c93e2b2d3e6768e20d5b6be0a2afd0ee3db324bdbde8c7fff571d6c16848efff49d58a4c1a2be6e286344f39759de411a0ce26369525495a9363af06cd0b0437e862ee7aea9f9a6e4401020f58efe8f7c577b3e9b74c494dc290d5734d7f539f56029b3d712353e81bd16d470e35b8cb38acb636b0b50da85cf282e318802240d81c16020f1d9a5c0ae6cf712082740008863ff9cc8aafb5f12bf98a35512c6065281c8d58da188b090a1ed13ec1bd42d173717f0e4c770192d47447122a19cfe75dc20f1cbecd0b502e3b55f47c935f9002b60bae8b294ded366cb30af02dfac0c23992c576cd5be6c34cba8b39201349e0c0f1a316ee37ae519d782310317bcb926c9a78f1876a18da63aee0e79ffceef6aea86564006e50307e26d172822c1cd4188f52afba75afeafd6dc9cb61b3c9498a6a2f1bd246f0637bd15783b4d85a5c3dcf53a8ee978e90821ef9829752db8e3781a235e4532a642dd0ce779580c60fae751790049d9a150af6916003845f88cf2d0b3799a73753dac30bab8931ba31af776ba83cfe3a4fd1e15838d9c3ad5c07c596e88a50948070d635520efcee7d704d25abea4b05540dbecec2f805be0d147c5dde7287f37bda2d1850171cb53f12d0682d3baf1e273c7e495b42c9e84923977925f8c87bb60169db84bedbdb1ea51955e00aee80f555acce7e64da12b3a450bed277b4e58311fdef08881c4b995b8ac37c9ff24012c5e3f2ab808efb3c288fa5ac78a4b2aff84e1167fc97157069d5eb1a4028a99583f639fe340f08002c3b63c9b4eaab8afa28683adbeb1a739b1cd458b1660689a243d8b84767da6f115bae17322efdfefa40ed1a72ba3922be9d7f40990d55f683f9baf67d2cbbc90f0163e158b728c31ea79ea444fe6816a3ff82faf5424f522e9953639485e7e931d103f4f67969f1f8f4c116c7ffca0644f1f839b227fac5984d3d9e3aaac47a9f2ba0748a75ef719718d665bf7b5ceec7f62bd707940251167fb953afd835ce5990e4dee9df837620571879197ed4e7daf522f5b3b629803fb29fa2fb5102ad5553d84edaf8d0bb90047bd691914d47dfa5e74c95b92d36a18b32aa1f832f41eb109716f6d876cd3f240359473859e8c18bb8a99edbc657448b8583a2ef8bc4f12b19a749fcbf7ae2038d2bc8b133d51604dc75748acacdff3f397fb3dbf576e7dddea5671b68d414d5794f0ef765bcc2ae32e3dc5c16a63df419b6c5a54fd49ec4ec9f254232441ca870487fd94776fd891d55560a135e4fcdc87de2e3ce9df04f1cbb7ea5689c8427e35155af95b98dd7b9a70d91b3a76fe47896d293a6e692252819edaf2f7667a0b7ac3bda67b0d97506ab66992538a01d1f787c2a2dc76ae43008864c7e862e6ffa0b3e1ff667aa6f77981aecd19b6d6f05e37f4fe723cbf8dee3cfdedecde885fd54af468ddca89e17ea475c8db6c50a2bc31550f6625e54dba1806a3bbe8524ca8ed071959e177e76e5ba4cc6a6d47f7c675028ee28459ab438bffe1e4870c5cd03cbaea7a6eaa44efd1079430083086426960656775111c4b7f437c0881fcc064849fc9774fb630fbfbcbbc7f34f0446d17d93f4a54c99fa644ada44910e5ddb16a9141aa652fe9bc518ed70364eb6536aba6e905bd371a5d1754ba2c4ddb09d32e0a1f26ed1beba10a2f6de78e609bf827eafaa06db42f5015ad6417b38a5ec65e7101e62ad61e1f24facb3545746b65bb12f36fa697f8d1c6b6dc3780f8b11e8281d1949e7cf84b1b4b0a66a7aea039a45c993fd4d8e7d3f828c8d13065235748e672b7a7f1dc9c06e2ad0d6286c3da1ec856fa74977ffffeef5c2b23a687d62a7d59c26e8cbbb55c20829441ca2b4ad9632eb47410a126c8bf8ff2a770221169b1ab7f34b90dd6ea4695d2847af12982906a12aa6ce00ef269725579b350ae4c00ae15d3d58b3d27b38ef26f34d79cfe680083a96dfc9426917ea4c3beac2a9c533bb9e5040fe87e1aebc8c7d3e92f86d83a0277bfddb6d27e6d71579fbe34e19d4f56722242f64f5e8f32b6cfb0be17f1b3c997a764e3dcb006da6e76368a81bacce7f0e696ae281bb30e9fc3283b2e49bf6e41cb29139e13a01c4562e0cc33bb73da64ec67cf84e74b942eb0b79da9bbbb053db5a81f175da2066785569e6b4f975670a8c2160aba59e27095a6b717de887cf0660134e8b86826ac9c137df03b9fc833b02bfeab5d1c0dfb1f3250e1a557b3c8c3d18db5ff346b10c1749dc611cab861dbe1425dd511c4dc7f8ed7c341fc4cbcd393f1f1f1a2d4febe589ae5d4c9dc95c97fc6e873974077ebbbd6d5d84f0301601dbf286dfad942ecba445473dd418d32ea7d54dee7f641f456c16c867145d78f2c21dd62ce8057e407f7785cbb78b981c89cb838d6883ad3db7b18559a16eb2ec71f2c759178269ed6b7b18f81ab33bc3b8ed5bf0df9eb044abb0f3673e97a88aa7fe1e57bc5e274119c66324236cebc9d8690e212b3d04459c9f409cc83918e61a041b32717b051fec6834939ce530d0bdf9000baef0d4d6b6d7b377b0bad721ad114aab93d23af3887b4f80dade7508c9f4138df59fed048a8e0a320b3baa4699603938ce44be8cf8ae3e890b15955e215aa25877b19dd2e1034a085789dc33fd36503149fe647f5de3ac8a113d8034f756df56d97d06b42ee1960835fd99f10271cdbd0924ae3694a91376e9773c8685e06d2b1fae5ffa7eb1767e8f8f25ad2c2beefff5fa899a2b6ee2ea8e31e04ce81b9a5f87e48b9d66511dc246ce416c8b9936021b16148346f5a6e647528a2153cbf036bcd16e3ce927e4309fe2f9a23bd263b7fc052cea12caf9d6b50910b2aeae88f393813ff770f3f8cf917d52f80aff69d3c2ed784125f011ee00c3d79b3d42318cedcd9a4f5693469fb5ede4b974910024dd18f8b90f8f0d4444225ef5ec74b947bc4030551acfe0a7aa9c9d6688a611ba19e00fc1e2a5563700591c51fd32f6d395cbf4814fac9a8e48346c9366f8e1b03e5dc9fa3201485430605dfb75ca7c1436a7faad8054e6b7c1cfe4daa5a1a10699b4a2b30f2f4718f19811cb43f9db9bf34d638a7af25ab44c1a1ecf149b7b04cd6820eec9fc4523242e0040f0dcde91a560b52c28eb1659e04603385490aa967d4fea52332f36e3cc2417083aedcf93fdf6cf8ffc7bf6fdaf3118642ae06761b5d6aed0a6d581d2e638c87a6067d8627283cdf22e11a131bad0aae2388b6b240dd5cb6e3521a712aee6a954e9961fd70039f9696341e022dd32afeca6fa77340e3de58c01b1901d6cd3e92e9320a4170760891a23a3b39adeb18e5584e01cbfdc1fff3be5915c1ccadd44b386041a1a46c15af6463bebb793bd6eb2edc7bd69acaf39f7cc5b4ed48496ae63c8cd9f0f97d3d39efe19a270cacb7be3ae54023b9e9e9e9e026516fa4d005bb478aa67d4acabd8466004dda1832e6448600fccdfcd60e0c6d19eca513cf1ea9e8f738af2ef935aedc4d5894d6298bdaef5675762ad45c0c53991b36da8245df713799c592f0b19bae413a3982b21519408c29c36cad42cfc0fd5deb08302c68f0fb06428b259b2ef4fe75f9dc672981ed08caf66290af3cc7ba2c23f6b14b1a8a677aed91b0b685c03f961b3f11891d53194fffcd055d314393b48827ae08b9a7e6435ef647f442d8951573cf5c67bb54527b23bc96a87b6e66e8c0ecea9adfc868b356361838cd8bad7788b0db9a9e096232b522c1e7b7d7d71009d54d9a95272b3cdd33b50890fd1331ed11e54d41c52cab9c7a50b717943e333a4d86d469a06bc21f83f6e9c96349e000b154ee1e4813aebdab771ff699e710dcada5a24e46da86eed88c41106b653aaf31d4f17bc6176835eb283f23b123c0fff3274c4657cecb787ce8449f396439498f813e52ded3371fde33d58319ac8201352d2420c5681f8a4dd71ed4c0b3cd8e8e71ecff76de7124e13db9aee950bab3d30a3bf8638f71d090df73b4eca07d25b28e15ac6f6413b708ed2e0feb8fb473da10882d38407bb81f8448b8a2bcfee00a59b8b542ce0e3cfa58b3b6fe077df96cb132a880ae6d82648bb7d0c63aa1d97cbb3743a767bcfc90350f8574ae75fae978758f76b512fe8d0a5c518c7485758f4f4ff96c7da285b39e8ed0eb51c5bc020da27ce5a1ff6f4274fe165662d2d3ef1f39b0eec2549cf72ed98b720ba95a0aa4a10657bc40faabe2242c14bbb8d881b9ee714739bb67f6aadcc77492f8446c6cdb42e160d1b8a4459c497f2b8bdd1ed7e8c36f84ea1399860e9c549c7e422cce3bc441f4b39a0c9533f9116b025b5d8c7c9202f59d21845fa81571337d402bc1b84448c7453ecd59538513cd4ea18d5ad75ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c95bb2bcacbc8939099e3e2a2e059636"};

const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                
                // --- C'EST ICI QU'ON CAPTE LE SUCC√àS ---
                replaceHtmlCallback: function(plainHTML) {
                    const user = localStorage.getItem('bts_ciel_username') || 'Inconnu';
                    const device = localStorage.getItem('bts_ciel_device_id') || '???';
                    
                    const topic = 'tscieltristan; 
                    

                    fetch(`https://ntfy.sh/${topic}`, {
                        method: 'POST',
                        body: `‚úÖ SUCC√àS\nüë§ Nom: ${user}\nüÜî ID: ${device}\nüéâ Le site a √©t√© d√©chiffr√©.`,
                        headers: { 'Title': 'Acc√®s Autoris√©', 'Tags': 'white_check_mark', 'Priority': 'default' },
                        keepalive: true
                    });

                    document.open();
                    document.write(plainHTML);
                    document.close();
                },
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // --- LOGIQUE MOUCHARD INTEGREE ---
            function getUniqueDeviceID() {
                let deviceID = localStorage.getItem('bts_ciel_device_id');
                if (!deviceID) {
                    const randomStr = Math.random().toString(36).substring(2, 6).toUpperCase();
                    deviceID = `User-${randomStr}`;
                    localStorage.setItem('bts_ciel_device_id', deviceID);
                }
                return deviceID;
            }

            // Pr√©-remplir le nom si d√©j√† venu
            const savedName = localStorage.getItem('bts_ciel_username');
            if(savedName) {
                document.getElementById('staticrypt-username').value = savedName;
            }

           // --- GESTION DE LA CONNEXION (AVEC ID UNIQUE) ---
            function getUniqueDeviceID() {
                let deviceID = localStorage.getItem('bts_ciel_device_id');
                if (!deviceID) {
                    const randomStr = Math.random().toString(36).substring(2, 6).toUpperCase();
                    deviceID = `User-${randomStr}`;
                    localStorage.setItem('bts_ciel_device_id', deviceID);
                }
                return deviceID;
            }

            // Pr√©-remplir le nom
            const savedName = localStorage.getItem('bts_ciel_username');
            if(savedName) {
                document.getElementById('staticrypt-username').value = savedName;
            }

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value;
                const username = document.getElementById("staticrypt-username").value.trim();
                const isRememberChecked = document.getElementById("staticrypt-remember").checked;
                
                // On sauvegarde le nom pour le callback de succ√®s
                if(username) localStorage.setItem('bts_ciel_username', username);
                
                // On s'assure d'avoir un ID
                const deviceID = getUniqueDeviceID();

                // TENTATIVE DE D√âCHIFFREMENT
                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                // --- SI C'EST UN √âCHEC ---
                if (!isSuccessful) {
                     const user = username || 'Inconnu';
                     const topic = 'tscieltristan'; 

                     fetch(`https://ntfy.sh/${topic}`, {
                        method: 'POST',
                        body: `‚ùå √âCHEC\nüë§ Nom: ${user}\nüÜî ID: ${deviceID}\n‚õî Mauvais mot de passe saisi.`,
                        headers: { 'Title': 'Acc√®s Refus√©', 'Tags': 'rotating_light,no_entry', 'Priority': 'high' },
                        keepalive: true
                    });
                    
                    alert("‚ùå Mot de passe incorrect !");
                }
                // Si c'est un SUCC√àS, c'est le "replaceHtmlCallback" (√©tape 1) qui s'en occupe.
            });
        </script>
    

</body></html>